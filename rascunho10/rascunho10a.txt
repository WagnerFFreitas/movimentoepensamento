Okay, vamos organizar e verificar o conteúdo consolidado do projeto para garantir que tudo esteja completo e funcional.

## Organização do Arquivo `PROJETO_MOVIMENTO_PENSAMENTO.txt`

Para facilitar a compreensão e o uso, vou organizar o conteúdo em seções mais claras e concisas:

### 1. Visão Geral do Projeto
 *  **Nome**: Movimento e Pensamento
 *  **Descrição**: Sistema completo de gestão para clínica de fisioterapia.
 *  **Tecnologias**:
   *   Backend: PHP
   *   Frontend: Vue.js
   *   Banco de Dados: MySQL
   *   Infraestrutura: Docker
   *   Autenticação: JWT
   *   Segurança: Criptografia, Middleware

### 2. Estrutura de Pastas
```
movimento-pensamento/
├── backend/
│   ├── config/
│   ├── controllers/
│   ├── models/
│   ├── services/
│   ├── middleware/
│   └── database/
├── frontend/
│   ├── src/
│   │   ├── components/
│   │   ├── services/
│   │   ├── router/
│   │   └── store/
│   └── docs/
```
### 3. Segurança
*   **Mecanismos**:
    *   Autenticação JWT
    *   Criptografia de senhas
    *   Middleware de autorização
    *   Classe de Segurança (`backend/security/Seguranca.php`) com métodos para gerar e validar tokens.
    *   Middleware de segurança (`backend/middleware/MiddlewareSeguranca.php`)
*   **Detalhes**:
```php
<?php
class Seguranca {
    // Métodos de geração de token
    public static function gerarToken($dados) {
        $header = json_encode([
            'alg' => 'HS256',
            'typ' => 'JWT'
        ]);

        $payload = json_encode([
            'dados' => $dados,
            'exp' => time() + (60 * 60 * 24) // 24 horas
        ]);

        $headerBase64 = base64_encode($header);
        $payloadBase64 = base64_encode($payload);

        $signature = hash_hmac(
            'sha256',
            "{$headerBase64}.{$payloadBase64}",
            self::$configuracoes['token_key'],
            true
        );

        $signatureBase64 = base64_encode($signature);

        return "{$headerBase64}.{$payloadBase64}.{$signatureBase64}";
    }

    // Métodos de validação de token
    public static function validarToken($token) {
        // Lógica de validação
    }
}
```
```php
<?php
class MiddlewareSeguranca {
    public static function validarToken($request, $response, $next) {
        $token = $request->getHeaderLine('Authorization');

        if (!$token) {
            return $response->withStatus(401)
                ->withJson(['erro' => 'Token não fornecido']);
        }

        try {
            $tokenDecodificado = Seguranca::validarToken($token);

            // Adicionar dados do usuário ao request
            $request = $request->withAttribute('usuario', $tokenDecodificado);

            return $next($request, $response);
        } catch (Exception $e) {
            return $response->withStatus(401)
                ->withJson(['erro' => 'Token inválido']);
        }
    }

    public static function validarPermissao($tiposPermitidos) {
        return function($request, $response, $next) use ($tiposPermitidos) {
            $usuario = $request->getAttribute('usuario');

            if (!in_array($usuario['tipo'], $tiposPermitidos)) {
                return $response->withStatus(403)
                    ->withJson(['erro' => 'Acesso não autorizado']);
            }

            return $next($request, $response);
        };
    }
}
```

### 4. Modelo de Banco de Dados
*   **Tabela `usuarios`**:
    ```sql
    CREATE TABLE usuarios (
        id INT AUTO_INCREMENT PRIMARY KEY,
        nome VARCHAR(255) NOT NULL,
        email VARCHAR(255) UNIQUE NOT NULL,
        senha VARCHAR(255) NOT NULL,
        tipo_usuario ENUM('paciente', 'profissional', 'admin') DEFAULT 'paciente',
        status ENUM('ativo', 'inativo', 'bloqueado') DEFAULT 'ativo',
        data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    ```
 * **Tabela `agendamentos`**
    ```sql
    CREATE TABLE agendamentos (
        id INT AUTO_INCREMENT PRIMARY KEY,
        paciente_id INT NOT NULL,
        profissional_id INT NOT NULL,
        data DATE NOT NULL,
        hora TIME NOT NULL,
        servico VARCHAR(100) NOT NULL,
        status ENUM('agendado', 'confirmado', 'cancelado', 'concluido') DEFAULT 'agendado',
        FOREIGN KEY (paciente_id) REFERENCES usuarios(id),
        FOREIGN KEY (profissional_id) REFERENCES usuarios(id)
    );
    ```

### 5. Componente Vue - Login (`frontend/src/components/auth/Login.vue`)
```vue
<template>
  <div class="login-container">
    <el-card>
      <el-form @submit.prevent="realizarLogin">
        <el-form-item>
          <el-input
            v-model="email"
            placeholder="E-mail"
          />
        </el-form-item>
        <el-form-item>
          <el-input
            v-model="senha"
            type="password"
            placeholder="Senha"
          />
        </el-form-item>
        <el-button type="primary" native-type="submit">
          Entrar
        </el-button>
      </el-form>
    </el-card>
  </div>
</template>

<script>
export default {
  data() {
    return {
      email: '',
      senha: ''
    }
  },
  methods: {
    async realizarLogin() {
      try {
        const resposta = await this.$store.dispatch('auth/login', {
          email: this.email,
          senha: this.senha
        });

        // Redirecionar baseado no tipo de usuário
        this.redirecionarUsuario(resposta.tipoUsuario);
      } catch (erro) {
        this.$message.error('Credenciais inválidas');
      }
    },
    redirecionarUsuario(tipoUsuario) {
      const rotas = {
        'paciente': '/paciente/dashboard',
        'profissional': '/profissional/dashboard',
        'admin': '/admin/dashboard'
      };

      this.$router.push(rotas[tipoUsuario] || '/');
    }
  }
}
</script>
```
### 6. Serviço de Autenticação (frontend)
```javascript
import ApiClient from './ApiClient';

export default {
  login(credenciais) {
    return ApiClient.post('/login', credenciais);
  },

  registrar(dadosUsuario) {
    return ApiClient.post('/registrar', dadosUsuario);
  },

  recuperarSenha(email) {
    return ApiClient.post('/recuperar-senha', { email });
  }
}
```
### 7. Estatísticas do Dashboard Admin
```vue
<template>
  <div class="dashboard-admin">
    <el-row>
      <el-col :span="6">
        <el-card>Total de Usuários: {{ estatisticas.totalUsuarios }}</el-card>
      </el-col>
      <el-col :span="6">
        <el-card>Agendamentos Hoje: {{ estatisticas.agendamentosHoje }}</el-card>
      </el-col>
    </el-row>
  </div>
</template>

<script>
export default {
  data() {
    return {
      estatisticas: {
        totalUsuarios: 0,
        agendamentosHoje: 0
      }
    }
  },
  methods: {
    async buscarEstatisticas() {
      const resposta = await this.$api.get('/admin/estatisticas');
      this.estatisticas = resposta.data;
    }
  },
  mounted() {
    this.buscarEstatisticas();
  }
}
</script>
```
### 8. Middleware de Segurança (Backend)
```php
<?php
class MiddlewareSeguranca {
    public static function validarToken($request, $response, $next) {
        $token = $request->getHeaderLine('Authorization');
        
        if (!$token) {
            return $response->withStatus(401)
                ->withJson(['erro' => 'Token não fornecido']);
        }

        try {
            $tokenDecodificado = Seguranca::validarToken($token);
            
            // Adicionar dados do usuário ao request
            $request = $request->withAttribute('usuario', $tokenDecodificado);
            
            return $next($request, $response);
        } catch (Exception $e) {
            return $response->withStatus(401)
                ->withJson(['erro' => 'Token inválido']);
        }
    }

    public static function validarPermissao($tiposPermitidos) {
        return function($request, $response, $next) use ($tiposPermitidos) {
            $usuario = $request->getAttribute('usuario');
            
            if (!in_array($usuario['tipo'], $tiposPermitidos)) {
                return $response->withStatus(403)
                    ->withJson(['erro' => 'Acesso não autorizado']);
            }

            return $next($request, $response);
        };
    }
}
```
### 9. Serviço de Agendamento (Backend)
```php
<?php
class AgendamentoService {
    private $conexao;

    public function __construct(Database $db) {
        $this->conexao = $db->conectar();
    }

    public function criarAgendamento($dadosAgendamento) {
        try {
            // Validar disponibilidade
            $this->validarDisponibilidade(
                $dadosAgendamento['profissional_id'],
                $dadosAgendamento['data'],
                $dadosAgendamento['hora']
            );

            // Inserir agendamento
            $stmt = $this->conexao->prepare(
                "INSERT INTO agendamentos
                (paciente_id, profissional_id, data, hora, servico)
                VALUES (:paciente_id, :profissional_id, :data, :hora, :servico)"
            );

            $stmt->execute($dadosAgendamento);

            // Enviar notificação
            $this->enviarNotificacao($dadosAgendamento);

            return $this->conexao->lastInsertId();
        } catch (Exception $e) {
            throw new Exception("Erro ao criar agendamento: " . $e->getMessage());
        }
    }

    private function validarDisponibilidade($profissionalId, $data, $hora) {
        $stmt = $this->conexao->prepare(
            "SELECT COUNT(*) FROM agendamentos
            WHERE profissional_id = :profissional_id
            AND data = :data
            AND hora = :hora
            AND status != 'cancelado'"
        );

        $stmt->execute([
            ':profissional_id' => $profissionalId,
            ':data' => $data,
            ':hora' => $hora
        ]);

        if ($stmt->fetchColumn() > 0) {
            throw new Exception("Horário já ocupado");
        }
    }

    private function enviarNotificacao($dadosAgendamento) {
        $notificacaoService = new NotificacaoService();
        $notificacaoService->enviarEmail(
            $dadosAgendamento['email_paciente'],
            'Agendamento Confirmado',
            "Seu agendamento para {$dadosAgendamento['servico']} foi confirmado."
        );
    }
}
```

### 10. Serviço de Notificação (Backend)
```php
<?php
class NotificacaoService {
    private $configuracoes;

    public function __construct() {
        $this->configuracoes = $this->carregarConfiguracoes();
    }

    public function enviarEmail($destinatario, $assunto, $corpo) {
        try {
            $mail = new PHPMailer(true);

            $mail->isSMTP();
            $mail->Host = $this->configuracoes['smtp_host'];
            $mail->SMTPAuth = true;
            $mail->Username = $this->configuracoes['smtp_usuario'];
            $mail->Password = $this->configuracoes['smtp_senha'];
            $mail->SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;
            $mail->Port = 587;

            $mail->setFrom('noreply@movimentoepensamento.com', 'Movimento e Pensamento');
            $mail->addAddress($destinatario);

            $mail->isHTML(true);
            $mail->Subject = $assunto;
            $mail->Body    = $corpo;

            $mail->send();
        } catch (Exception $e) {
            throw new Exception("Erro ao enviar e-mail: {$mail->ErrorInfo}");
        }
    }

    public function enviarSMS($telefone, $mensagem) {
        // Implementação de envio de SMS
    }

    public function registrarNotificacao($usuarioId, $tipo, $mensagem) {
        // Salvar notificação no banco de dados
    }
}
```
### 11. Relatórios e Estatísticas (Backend)
```php
<?php
class RelatorioService {
    private $conexao;

    public function __construct(Database $db) {
        $this->conexao = $db->conectar();
    }

    public function gerarRelatorioAgendamentos($filtros) {
        $query = "SELECT 
            COUNT(*) as total_agendamentos,
            SUM(CASE WHEN status = 'confirmado' THEN 1 ELSE 0 END) as confirmados,
            SUM(CASE WHEN status = 'cancelado' THEN 1 ELSE 0 END) as cancelados,
            AVG(DATEDIFF(NOW(), data)) as media_dias
        FROM agendamentos
        WHERE 1=1 ";

        $parametros = [];

        if (!empty($filtros['data_inicio'])) {
            $query .= " AND data >= :data_inicio";
            $parametros[':data_inicio'] = $filtros['data_inicio'];
        }

        if (!empty($filtros['data_fim'])) {
            $query .= " AND data <= :data_fim";
            $parametros[':data_fim'] = $filtros['data_fim'];
        }

        $stmt = $this->conexao->prepare($query);
        $stmt->execute($parametros);

        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    public function gerarRelatorioFinanceiro($filtros) {
        $query = "SELECT 
            SUM(valor) as receita_total,
            COUNT(*) as total_atendimentos,
            AVG(valor) as media_valor
        FROM transacoes
        WHERE 1=1 ";

        $parametros = [];

        if (!empty($filtros['data_inicio'])) {
            $query .= " AND data >= :data_inicio";
            $parametros[':data_inicio'] = $filtros['data_inicio'];
        }

        if (!empty($filtros['data_fim'])) {
            $query .= " AND data <= :data_fim";
            $parametros[':data_fim'] = $filtros['data_fim'];
        }

        $stmt = $this->conexao->prepare($query);
        $stmt->execute($parametros);

        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    public function exportarRelatorio($tipo, $dados) {
        switch($tipo) {
            case 'csv':
                return $this->exportarCSV($dados);
            case 'pdf':
                return $this->exportarPDF($dados);
            default:
                throw new Exception("Tipo de relatório não suportado");
        }
    }

    private function exportarCSV($dados) {
        // Implementação para exportar dados em CSV
    }

    private function exportarPDF($dados) {
        // Implementação para exportar dados em PDF
    }
}
```
### 11. Agendamento de Tarefas (Cron)
```php
<?php
class CronJob {
    public function limparDadosAntigos() {
        $db = new Database();
        $conexao = $db->conectar();

        $stmt = $conexao->prepare("DELETE FROM agendamentos WHERE data < NOW() - INTERVAL 30 DAY");
        $stmt->execute();
    }
}
```
### 12. Documentação da API
* **Base URL**: `https://api.movimentoepensamento.com/v1`
* **Autenticação**: JWT
* **Endpoints**:
    * `POST /login`: Realiza login e retorna token.
    * `POST /registrar`: Registra um novo usuário.
    * `GET /usuarios`: Retorna lista de usuários (requer autenticação).
    * `POST /agendamentos`: Cria um novo agendamento (requer autenticação).
    * `GET /estatisticas`: Retorna estatísticas do sistema (requer autenticação).

### 13. Testes
*   **Testes Unitários**: Utilizar PHPUnit
    *   Cobertura mínima de 80% para classes principais
    *   Testar métodos de serviços e controladores.
*   **Testes de Integração**: Verificar fluxo de autenticação e autorização.
*    **Estrutura:**
```
tests/
├── Unit/
│   ├── AuthTest.php
│   ├── AgendamentoTest.php
│   └── UsuarioTest.php
│
├── Integration/
│   ├── ApiTest.php
│   └── WorkflowTest.php
│
└── E2E/
    ├── LoginFlowTest.php
    └── AgendamentoFlowTest.php

```
Exemplo de teste:

```php
<?php
use PHPUnit\Framework\TestCase;

class AuthTest extends TestCase {
    public function testLoginValido() {
        $authService = new AuthService();
        $resultado = $authService->login('email@teste.com', 'senha123');

        $this->assertTrue($resultado['sucesso']);
        $this->assertNotNull($resultado['token']);
    }

    public function testLoginInvalido() {
        $authService = new AuthService();
        $resultado = $authService->login('email@invalido.com', 'senhaerrada');

        $this->assertFalse($resultado['sucesso']);
    }
}
```

### 14. Continuidade do Projeto
*   **Manutenção e Suporte**: Plano de manutenção regular, canal de suporte.
*   **Feedback e Melhorias**: Coletar feedback e planejar atualizações.

### 15. Considerações Finais
*   Projeto estruturado para segurança, escalabilidade e experiência do usuário.
*   Documentação e testes são essenciais.

## Verificação de Pendências e Próximos Passos
*   **Pendências:**
    *   Implementar área do profissional
    *   Implementar área administrativa
    *   Implementar testes unitários e de integração
    *   Configurar ambiente de produção
    *   Documentar detalhadamente
*   **Próximos passos**:
   *   Implementar a área do profissional
   *    Finalizar a área administrativa
    *  Realizar testes unitários e de integração
    *  Configurar ambiente de produção
    * Documentar completamente
*  **Estimativa de Trabalho**:
    *  Desenvolvimento restante: 120-190 horas

**Verificação**:

Com base na revisão, o projeto parece estar bem encaminhado, mas as seguintes ações são necessárias:

1. **Implementação da área do profissional**:  Concluir os componentes Vue, serviços e rotas para a área do profissional. Incluir a lógica para histórico de pacientes e gestão de atendimentos.

2. **Área Administrativa**: Concluir todos os componentes administrativos, incluindo relatórios financeiros detalhados e configurações avançadas.

3. **Testes**: Implementar testes unitários para todos os componentes e serviços principais, e realizar testes de integração abrangentes.

4. **Configurações de Ambiente**: Definir variáveis de ambiente no backend, criar arquivos de configuração no frontend e preparar um ambiente de produção com Docker.

5. **Documentação**: Criar um manual técnico completo, documentar toda a API, elaborar um guia de instalação detalhado e um README completo.

6. **Revisão de Segurança**: Realizar uma auditoria de segurança para identificar e mitigar possíveis vulnerabilidades. Implementar proteção contra CSRF, refresh de token.

## Conclusão
Com o detalhamento acima, o projeto está em um estado mais organizado e completo, facilitando os próximos passos para a sua finalização. Os pontos listados acima como pendências devem ser tratados com prioridade para garantir que o sistema esteja funcional, seguro e pronto para produção.

Se você tiver alguma dúvida ou precisar de alguma ação adicional, me diga!
